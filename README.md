# Лабораторная работа №9-12: Продвинутое ООП на Kotlin
## Описание
Лабораторная работа посвящена изучению продвинутых концепций объектно-ориентированногопрограммирования в Kotlin. ## Структура проекта
Проект содержит примеры реализации продвинутых механизмов ООП, а также пояснения к ключевымконцепциям. ## Как запустить проект
1. Клонируйте репозиторий: ```bash
git clone <URL_репозитория>
``` 2. Откройте проект в IntelliJ IDEA. 3. Запустите любой пример через контекстное меню или напрямую из `main`. ## Автор
   [Ваше ФИО]
## Лицензия
Проект создан в учебных целях.
# 1.Геттеры, сеттеры и инкапсуляция
Использование кастомных геттеров и сеттеров идля контроля доступа к свойствам.
Пример:
```Kotlin
class Hero(val name: String) {
var health: Int = 100
set(value){
field = value.coerceIn(0,100)
}
}
```
# 2. Data-классы
Пример:
```Kotlin
data class OutpostResource(val id: Int,
                           val name: String,
                           var amount: Int)
```
# 3. Абстрактные классы
Создание базовой логики для наследников.
Пример:
```Kotlin
abstract class OutpostModule(
    val name: String,
    var level: Int=1
) {
    abstract fun performAction(manager: ResourceManager)
}
```
# 4. Интерфейсы
Реализация контрактов для классов.
Пример:
```Kotlin
interface ModuleAction {
    fun execute(manager: ResourceManager)
}
```
# Galaxy Outpost Manager
***
Учебный проект на Kotlin, демонстрирующий основы объектно-ориентированного программирования и архитектурные приёмы языка.

---

## Sealed-классы
***
**Sealed-классы** используются для представления ограниченного набора состояний или результатов, которые известны на этапе компиляции.

Они позволяют:
* гарантировать обработку всех возможных вариантов;
* безопасно использовать конструкцию when без else;
* удобно описывать состояния, события и результаты действий.

## Пример: результат работы модуля
```Kotlin
sealed class ModuleResult {
data class Success(val message: String) : ModuleResult()
data class ResourceProduced(val resourceName: String, val amount: Int) : ModuleResult()
data class NotEnoughResources(
val resourceName: String,
val required: Int,
val available: Int
) : ModuleResult()
data class Error(val reason: String) : ModuleResult()
}
```
# Object в Kotlin
***

**Object** — это специальная конструкция Kotlin, которая создаёт единственный экземпляр класса (Singleton).

Особенности:
* создаётся при первом обращении;
* существует в одном экземпляре;
* не имеет конструктора.

## Пример: глобальный логгер
```Kotlin
object Logger {
private var counter = 0

    fun log(message: String) {
        counter++
        println("[$counter] $message")
    }
}
```

## Использование:
```Kotlin
Logger.log("Инициализация системы")
Logger.log("Модуль запущен")
```

**object** удобно использовать для:
* логгеров;
* конфигураций;
* состояний без данных в sealed-классах;
* утилитарных классов.

***

# Делегирование свойств 

** Делегирование свойств** позволяет передать логику хранения и обработки значения другому объекту. 
В Kotlin это реализуется с помощью ключевого слова by. 

## Преимущества: 
* уменьшение дублирования кода;
* централизованная логика проверки и обработки данных;
* более чистый и читаемый код. 

**Пример**: ограничение диапазона значения энергии
```kotlin
var energy: Int by Delegates.observable(100) { _, old, new ->
println("Энергия изменилась: $old → $new")
}
```
## Lazy (ленивая инициализация)
**lazy** позволяет инициализировать объект только при первом обращении к нему. Это полезно, если: объект создаётся не всегда;
его создание ресурсоёмкое; нужно отложить инициализацию. 
Пример: 
```kotlin
val resourceManager by lazy {
ResourceManager()
}
```

Объект ResourceManager будет создан только при первом использовании. Observer-паттерн (наблюдатель)
Observer-паттерн позволяет объектам реагировать на изменения состояния другого объекта. 

**В проекте Galaxy Outpost Manager наблюдатели могут:**
- реагировать на изменение ресурсов; 
- логировать события;
- уведомлять пользователя. 

**Пример идеи:** 
ResourceManager изменяет ресурсы; наблюдатель выводит сообщение в консоль при изменении. 

## Сохранение состояния 
Для сохранения состояния проекта используется сериализация в JSON. 

**Это позволяет:** 
- сохранять данные между запусками программы; 
- хранить состояние в человекочитаемом формате; 
- легко перенести логику в Android-приложение.